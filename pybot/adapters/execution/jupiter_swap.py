from __future__ import annotations

from typing import Any

import requests

from pybot.app.ports.execution_port import (
    ExecutionPort,
    SubmitSwapRequest,
    SwapConfirmation,
    SwapSubmission,
)
from pybot.app.ports.logger_port import LoggerPort
from pybot.adapters.execution.jupiter_quote_client import JupiterQuoteClient
from pybot.adapters.execution.jupiter_quote_client import USDC_MINT
from pybot.adapters.execution.solana_sender import SolanaSender

SWAP_API_URL = "https://lite-api.jup.ag/swap/v1/swap"
SOL_ATOMIC_MULTIPLIER = 1_000_000_000
USDC_ATOMIC_MULTIPLIER = 1_000_000


class JupiterSwapAdapter(ExecutionPort):
    def __init__(self, quote_client: JupiterQuoteClient, solana_sender: SolanaSender, logger: LoggerPort):
        self.quote_client = quote_client
        self.solana_sender = solana_sender
        self.logger = logger

    def submit_swap(self, request: SubmitSwapRequest) -> SwapSubmission:
        quote = self.quote_client.fetch_quote(request)
        swap_transaction = self._fetch_swap_transaction(quote.raw)
        tx_signature = self.solana_sender.send_versioned_transaction_base64(swap_transaction)

        if request.side == "BUY_SOL_WITH_USDC":
            spent_quote_usdc = quote.in_amount_atomic / USDC_ATOMIC_MULTIPLIER
            filled_base_sol = quote.out_amount_atomic / SOL_ATOMIC_MULTIPLIER
        else:
            spent_quote_usdc = quote.out_amount_atomic / USDC_ATOMIC_MULTIPLIER
            filled_base_sol = quote.in_amount_atomic / SOL_ATOMIC_MULTIPLIER

        avg_fill_price = spent_quote_usdc / filled_base_sol if filled_base_sol > 0 else 0
        return SwapSubmission(
            tx_signature=tx_signature,
            in_amount_atomic=quote.in_amount_atomic,
            out_amount_atomic=quote.out_amount_atomic,
            order={"tx_signature": tx_signature},
            result={
                "status": "ESTIMATED",
                "avg_fill_price": avg_fill_price,
                "spent_quote_usdc": spent_quote_usdc,
                "filled_base_sol": filled_base_sol,
            },
        )

    def confirm_swap(self, tx_signature: str, timeout_ms: int) -> SwapConfirmation:
        confirmation = self.solana_sender.confirm_signature(tx_signature, timeout_ms)
        return SwapConfirmation(confirmed=confirmation.confirmed, error=confirmation.error)

    def get_mark_price(self, pair: str) -> float:
        if pair != "SOL/USDC":
            raise ValueError(f"Unsupported pair for mark price: {pair}")

        quote = self.quote_client.fetch_quote(
            SubmitSwapRequest(
                side="SELL_SOL_FOR_USDC",
                amount_atomic=SOL_ATOMIC_MULTIPLIER,
                slippage_bps=1,
                only_direct_routes=False,
            )
        )
        out_usdc = quote.out_amount_atomic / USDC_ATOMIC_MULTIPLIER
        if out_usdc <= 0:
            raise RuntimeError(
                f"Invalid mark price quote: outAmountAtomic={quote.out_amount_atomic}"
            )
        return out_usdc

    def get_available_quote_usdc(self, pair: str) -> float:
        if pair != "SOL/USDC":
            raise ValueError(f"Unsupported pair for quote balance: {pair}")
        return self.solana_sender.get_spl_token_balance_ui_amount(USDC_MINT)

    def get_available_base_sol(self, pair: str) -> float:
        if pair != "SOL/USDC":
            raise ValueError(f"Unsupported pair for base balance: {pair}")
        return self.solana_sender.get_native_sol_balance_ui_amount()

    def _fetch_swap_transaction(self, quote_response: dict[str, Any]) -> str:
        payload = {
            "quoteResponse": quote_response,
            "userPublicKey": self.solana_sender.get_public_key_base58(),
            "wrapAndUnwrapSol": True,
        }
        try:
            response = requests.post(
                SWAP_API_URL,
                json=payload,
                timeout=30,
                headers={"Content-Type": "application/json"},
            )
        except Exception as error:
            raise RuntimeError(f"Jupiter swap request failed: {error}") from error

        if response.status_code != 200:
            raise RuntimeError(f"Jupiter swap failed: HTTP {response.status_code}")

        data = response.json()
        swap_transaction = data.get("swapTransaction")
        if not isinstance(swap_transaction, str):
            raise RuntimeError("Jupiter swap payload is missing swapTransaction")
        self.logger.info("Swap transaction generated by Jupiter")
        return swap_transaction
